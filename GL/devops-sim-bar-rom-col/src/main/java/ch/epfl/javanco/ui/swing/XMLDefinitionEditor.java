package ch.epfl.javanco.ui.swing;

import java.awt.Dimension;
import java.awt.Frame;
import java.awt.Point;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.util.EventObject;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import javax.swing.BorderFactory;
import javax.swing.Box;
import javax.swing.BoxLayout;
import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JDialog;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JScrollPane;
import javax.swing.JSplitPane;
import javax.swing.JTable;
import javax.swing.JTree;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.table.AbstractTableModel;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeModel;

import org.dom4j.Attribute;

import ch.epfl.javanco.event.PropertiesTableModelEvent;
import ch.epfl.javanco.graphics.IconLoader;
import ch.epfl.javanco.network.AbstractElementContainer;
import ch.epfl.javanco.network.ElementEditor;
import ch.epfl.javanco.xml.JavancoXMLElement;
import ch.epfl.javanco.xml.NetworkAttribute;
import ch.epfl.javanco.xml.XMLTagKeywords;


/**
 * This class handles the graphical display of the properties of a chosen element (i.e. node, link or layer).<br>
 * The properties are displayed in a <code>JDialog</code> in a similar arborescence to the arborescence
 * of the corresponding XML document.<br/>
 * The attributes are grouped in three main groups:
 * <ul>
 * <li> "floating attributes" contains the attributes that aren't linked to any of the two other groups,
 * <li> "main_description" contains the most important information of this element,
 * 		usually related to its topology,
 * <li> "additional_description" contains additional information that is less important.
 * </ul>
 * If the properties are not in read-only mode, the user has the possibility to add attributes,
 * delete attributes or change the value of most attributes through this dialog.<br>
 * <br>
 * To handle the events generated by a change on the table and update the element's attributes
 * accordingly, a nested class <code>PropertiesTableModelListener</code> has been defined, which
 * implements {@link TableModelListener}. This implementation allows the user to confirm or
 * discard the changes they have done before closing the window. In order to do that, all the
 * {@link TableModelEvent}s are stored in a buffer rather than executed directly.<br>
 * <br>
 * This implies that the <code>JTable</code> content may not correspond exactly to the element's
 * attributes list (e.g. an attribute may have been deleted by the user, so it is deleted
 *  from the table content but not from the attributes list as long as the properties dialog
 *  is open). Therefore, the information stored in the <code>TableModelEvent</code> class,
 *  i.e. the row and column numbers of the cell which has changed, doesn't suffice to find
 *  the corresponding attribute. Thus an extension of <code>TableModelEvent</code> has been
 *  implemented, {@link PropertiesTableModelEvent}, which also gives the name, value and type
 *  of the corresponding attribute.
 * @author lchatela
 */
public class XMLDefinitionEditor extends JDialog implements ElementEditor {

	public static final long serialVersionUID = 0;

	private class XMLElementNodeTree extends DefaultMutableTreeNode {

		public static final long serialVersionUID = 0;
		private String display;

		XMLElementNodeTree(JavancoXMLElement e) {
			super(e);
			display = e.getName();
		}

		XMLElementNodeTree(JavancoXMLElement e, String s) {
			super(e);
			display = s;
		}

		@Override
		public String toString() {
			return display;
		}
	}

	private class XMLElementTree {
		DefaultTreeModel treeModel = null;

		private TreeModel getTreeModel() {
			return treeModel;
		}

		private void recurse(DefaultMutableTreeNode father, JavancoXMLElement e) {
			for (JavancoXMLElement iterator : e.elements()) {
				XMLElementNodeTree elementNode = new XMLElementNodeTree(iterator);
				father.add(elementNode);
				recurse(elementNode, iterator);
			}
		}

		private XMLElementTree(Map<String, JavancoXMLElement> elements, String name) {
			DefaultMutableTreeNode treeRootNode = new DefaultMutableTreeNode(name);
			treeModel = new DefaultTreeModel(treeRootNode);
			for (Map.Entry<String, JavancoXMLElement> entry : elements.entrySet()) {
				XMLElementNodeTree elementNode = new XMLElementNodeTree(entry.getValue(), entry.getKey());
				treeRootNode.add(elementNode);
				recurse(elementNode, entry.getValue());
			}
		}
	}

	/**********************************************************************************
	 * 								TABLE MODEL LISTENER
	 **********************************************************************************/
	/**
	 * This class handles the <code>TableModelEvent</code> fired when a change occurres
	 * in the <code>JTable</code> displaying the attributes.<br>
	 * The events are stored until the user clicks on "ok" or "cancel". Until that, only the displayed
	 * table is modified, not the real attributes. If the user clicks on "ok", the changes are
	 * then really executed.
	 * @author lchatela
	 */
	private class PropertiesTableModelListener implements TableModelListener {

		/** Contains all the events to execute if the user validates their changes */
		private Vector<PropertiesTableModelEvent> eventBuffer = new Vector<PropertiesTableModelEvent>();

		/**
		 * This method is called when a change occurres in the <code>JTable</code>.<br>
		 * It stores the event in the <code>eventBuffer</code>.
		 * @param e the <code>TableModelEvent</code> containing information about the
		 * 		change
		 */
		public void tableChanged(TableModelEvent e) {
			if (e instanceof PropertiesTableModelEvent) {
				eventBuffer.add((PropertiesTableModelEvent) e);
			}
		}

		/**
		 * Executes the action corresponding to each of the {@link PropertiesTableModelEvent}
		 * stored (i.e. update, insert and delete).<br/>
		 * This method is called when the user clicks on "ok" in the properties window.
		 */
		private void executeEvents() {
			PropertiesTableModel model = null;
			java.util.Set<JavancoXMLElement> toConstruct = new java.util.HashSet<JavancoXMLElement>();
			for (PropertiesTableModelEvent event : eventBuffer) {
				if (model == null) {
					model = (PropertiesTableModel) event.getSource();
				}
				List<?> attributes = model.getAttributeList();
				JavancoXMLElement el = model.getElement();
				String name = event.getAttName();
				// stores the JavancoXMLElements corresponding to an AbstractElement to reconstruct
				JavancoXMLElement properties = el.selectSingleElement("ancestor-or-self::properties");
				if (properties != null) {
					JavancoXMLElement parent = properties.getParent();
					if(parent.getAssociatedContainer() != null
							&& parent.getAssociatedContainer().getContainedElement() != null) {
						toConstruct.add(parent);
					}
				}

				// applies the action which fired the event
				switch (event.getType()) {
				case TableModelEvent.UPDATE:
					NetworkAttribute attChanged = get(attributes, name);
					if (attChanged == null) {
						throw new IllegalStateException("No attribute with the name " + name);
					}
					int col = event.getColumn();
					String newValue = event.getCol(col);
					updateAttribute(attChanged, col, newValue);
					break;
				case TableModelEvent.INSERT:
					String value = event.getAttValue();
					addAttribute(el, name, value);
					break;
				case TableModelEvent.DELETE:
					NetworkAttribute attToDelete = get(attributes, name);
					deleteAttribute(el, attToDelete, event);
					break;
				}
			}
			// reconstruction of the AbstractElements if needed
			// we suppose the AbstractElement already exists and only needs to be updated
			for (JavancoXMLElement parent : toConstruct) {
				JavancoXMLElement constructing = parent.selectSingleElement("child::properties");
				AbstractElementContainer container = parent.getAssociatedContainer();
				java.io.ByteArrayOutputStream errorBuffer = new java.io.ByteArrayOutputStream();
				container.getContainedElement().construct(constructing, errorBuffer);
				if (errorBuffer.size() != 0) {
					PopupDisplayer.popupErrorMessage(errorBuffer.toString(), frame);
				}
			}
		}



		/**
		 * Updates the attribute field with the given value.<br/>
		 * If <code>field = COL_VALUE</code>,
		 * updates the <b>value</b> field of the attribute, <br/>
		 * if <code>field = COL_TYPE COL_TYPE</code>,
		 * changes the <b>type</b> of the attribute (not implemented yet).
		 * @param attChanged the {@link NetworkAttribute} to update
		 * @param field the attribute field to update
		 * @param newValue the new value
		 */
		private void updateAttribute(NetworkAttribute attChanged, int field, String newValue) {
			switch(field){
			case COL_VALUE:
				attChanged.setValue(newValue);
				break;
			case COL_TYPE:
				// not implemented
				break;
			default:
				throw new IllegalStateException("Cannot update this attribute field.");
			}
			modified = true;
		}

		/**
		 * Adds a new {@link NetworkAttribute} to the given {@link JavancoXMLElement},
		 * with the given name and value.
		 * @param el the element to which to add the attribute
		 * @param name the name of the new attribute
		 * @param value the value of the new attribute
		 */
		private void addAttribute(JavancoXMLElement el, String name, String value) {
			AbstractElementContainer container = el.getAssociatedContainer();
			if (container == null) {

				el.add(new NetworkAttribute(XMLTagKeywords.parse(name), value, container));
			} else {
				if (container.attribute(name, false) != null) {
					PopupDisplayer.popupErrorMessage("Warning! The attribute "+name+" = "+value+" could not be added." +
							"\nReason:\n\""+ name + "\" is already used in this object. " +
							"Please use another name for your attribute.", frame);
				} else {
					if (el.getAssociatedKeyword() != null) {
						container.linkAttribute(XMLTagKeywords.parse(name), el.getAssociatedKeyword()).setValue(value);
					} else {
						NetworkAttribute toAdd = container.attribute(XMLTagKeywords.parse(name));
						toAdd.setValue(value);
						el.add(toAdd);
					}
				}
			}
		}

		/**
		 * Removes the given {@link NetworkAttribute} from the given {@link JavancoXMLElement}>.
		 * If the attribute is associated to a container, removes it from
		 * the container as well.
		 * @param el the element from which to remove the attribute
		 * @param toRemove the attribute to remove
		 */
		private void deleteAttribute(JavancoXMLElement el, NetworkAttribute toRemove, EventObject e) {
			AbstractElementContainer container = toRemove.getContainer();
			el.remove(toRemove);
			if (container != null) {
				container.removeAttribute(toRemove, e);
			}

		}
	}
	/*************************************************************************************
	 * 									TABLE MODEL
	 *************************************************************************************/
	/**
	 * This class is used as a <code>TableModel</code> for the <code>JTable</code>
	 * displaying the properties of an element.<br/>
	 * It is related to a unique <code>JavancoXMLElement</code> and its content
	 * is the <code>JavancoXMLElement</code> attributes.
	 * @author lchatela
	 */
	private class PropertiesTableModel extends AbstractTableModel {

		public static final long serialVersionUID = 0;
		private Vector<Object[]> content = null;
		private Object[] header = null;

		/** The <code>JavancoXMLElement</code> represented in this model */
		private JavancoXMLElement el = null;

		/** The list of attributes of the represented element */
		private List<NetworkAttribute> attList = null;

		/**
		 * Creates a new <code>PropertiesTableModel</code> with default column names.
		 * @param el The represented element
		 */
		private PropertiesTableModel(JavancoXMLElement el) {
			this(el, new String[]{"Name","Value","Type"});
		}

		/**
		 * Creates a new <code>PropertiesTableModel</code> with specified column names.
		 * @param el The represented element
		 * @param columnNames The column names
		 */
		private PropertiesTableModel(JavancoXMLElement el, Object[] columnNames){
			this.header = columnNames;
			this.el = el;
			this.attList = el.attributes();
			initContent(attList);
		}

		/**
		 * Initializes the <code>JTable</code> content with the given
		 * attribute list.
		 * @param attributes The attributes to display in the <code>JTable</code>
		 */
		private void initContent(List<NetworkAttribute> attributes){
			content = new Vector<Object[]>();
			int i = 0;
			for (Attribute attr : attributes) {
				Object[] row = createRow(attr.getName(), attr.getValue());
				content.add(i, row);
				i++;
			}
		}

		/**
		 * Creates an object corresponding to one row of the <code>JTable</code>.<br/>
		 * The type value is derived by casting the <code>value</code>.
		 */
		private Object[] createRow(String name, String value) {
			Object[] row = new Object[3];
			row[COL_NAME] = name;
			row[COL_VALUE] = value;
			try {
				row[COL_VALUE] = new Double(value);
			}
			catch (NumberFormatException ex) {}
			try {
				row[COL_VALUE] = new Integer(value);
			}
			catch (NumberFormatException ex) {}
			if ((value.equals("true")) || (value.equals("false"))) {
				row[COL_VALUE] = new Boolean(value);
			}
			row[COL_TYPE] = row[COL_VALUE].getClass();
			return row;
		}

		/** Returns the represented element. */
		private JavancoXMLElement getElement(){
			return el;
		}

		/** Returns the represented element attributes list. */
		private List<NetworkAttribute> getAttributeList() {
			return attList;
		}

		/**
		 * Removes the row with the given number from the <code>JTable</code>
		 * and fires a <code>PropertiesTableModelEvent</code> of type <code>TableModelEvent.DELETE</code>.
		 * @param row the number of the row to delete
		 */
		private void removeRow(int row) {
			String name = getValueAt(row, COL_NAME)+"";
			String value = getValueAt(row, COL_VALUE)+"";
			String type = getValueAt(row, COL_TYPE)+"";
			content.remove(row);

			fireTableRowDeleted(row, name, value, type);
		}

		/**
		 * Adds a new row at the end of the <code>JTable</code>, created from the given values, and <br/>
		 * fires a <code>PropertiesTableModelEvent</code> of type <code>TableModelEvent.INSERT</code>.
		 * @param name the name of the attribute represented in the new row
		 * @param value the value of the attribute represented in the new row
		 */
		private void addRow(String name, String value) {
			for (Object[] existing : content) {
				// Verifys that the name is not already used in *this* element.
				// The verification with all the attributes of the container is done
				// only when the user clicks on "ok"
				if (existing[COL_NAME].equals(name)) {
					PopupDisplayer.popupErrorMessage("\""+ name + "\" is already used. Please use another name for your attribute.", frame);
					return;
				}
			}
			int size = getRowCount(); // Remark: size - 1 = last line before the insertion
			Object[] newRow = createRow(name, value);
			content.add(newRow);
			String objValue = newRow[COL_VALUE]+"";
			String objType = newRow[COL_TYPE]+"";

			fireTableRowInserted(size, name, objValue, objType);

		}

		/* implementation of AbstractTableModel */

		public int getRowCount(){
			return content.size();
		}
		public int getColumnCount(){
			return header.length;
		}
		public Object getValueAt(int row, int column){
			return content.get(row)[column];
		}

		@Override
		public String getColumnName(int col){
			return header[col].toString();
		}

		/**
		 * Indicates to the <code>JTable</code> whether this cell is editable.<br/>
		 * In this model, all cells are editable except the "Name" column, the rows corresponding to
		 * a CORE attribute or an attribute specified as uneditable.
		 * @param row the row being queried
		 * @param col the column being queried
		 * @return <code>true</code> if the cell can be edited, <code>false</code> otherwise
		 */
		@Override
		public boolean isCellEditable(int row, int col) {
			// if readOnly=true, no cell is editable
			if (readOnly) {
				return false;
			}
			// the name is not editable
			if (col == COL_NAME) {
				return false;
				// Core attributes are not editable
			} else {
				String name = getValueAt(row, COL_NAME)+"";
				if (XMLTagKeywords.parse(name).isCore()) {
					return false;
				}
				// User created attributes are editable, the others as specified
				NetworkAttribute att = get(attList, name);
				return (att == null || att.isEditable());
			}
		}

		/**
		 * Changes the value of the given cell and fires a
		 * <code>PropertiesTableModelEvent</code> of type <code>TableModelEvent.UPDATE</code>.
		 */
		@Override
		public void setValueAt(Object value, int row, int col) {
			// the column NAME (0) is never editable
			assert col != COL_NAME;

			Object[] currRow = content.get(row);
			if (col == COL_TYPE) {
				// changes the type column value
				Class<?> newValue = null;
				try {
					newValue = (Class<?>) value;
				} catch(ClassCastException ex) {
					return;
				}
				currRow[col] = newValue;
			} else {
				// changes the value column value
				currRow[col] = value;
			}
			content.set(row, currRow);

			String name = getValueAt(row, COL_NAME)+"";
			String attType = getValueAt(row, COL_TYPE)+"";
			fireTableCellUpdated(row, col, name, value+"", attType);
		}

		@Override
		public Class<?> getColumnClass(int col) {
			// to add if a cell editor is implemented
			/* if (col == COL_TYPE) {
	    		return Class.class;
	    	}*/
			return Object.class;
		}

		/* "overriding" of the fire methods in order to create PropertiesTableModelEvent events */
		/**
		 * Fires a <code>PropertiesTableModelEvent</code> of type <code>TableModelEvent.DELETE</code>.
		 */
		private void fireTableRowDeleted(int row, String name, String value, String attType) {
			fireTableChanged(new PropertiesTableModelEvent(this, row,
					TableModelEvent.ALL_COLUMNS, TableModelEvent.DELETE, name, value, attType));
		}

		/**
		 * Fires a <code>PropertiesTableModelEvent</code> of type <code>TableModelEvent.INSERT</code>.
		 */
		private void fireTableRowInserted(int row, String name, String value, String attType) {
			fireTableChanged(new PropertiesTableModelEvent(this, row,
					TableModelEvent.ALL_COLUMNS, TableModelEvent.INSERT, name, value, attType));
		}

		/**
		 * Fires a <code>PropertiesTableModelEvent</code> of type <code>TableModelEvent.UPDATE</code>.
		 */
		private void fireTableCellUpdated(int row, int column, String name, String value, String attType) {
			fireTableChanged(new PropertiesTableModelEvent(this, row,
					column, TableModelEvent.UPDATE, name , value, attType));
		}


	}

	/******************************************************************************************
	 * 							XML DEFINITION EDITOR
	 ******************************************************************************************/

	/** The column number of the "name" column */
	public static final int COL_NAME = 0;

	/** The column number of the "value" column */
	public static final int COL_VALUE = 1;

	/** The column number of the "type" column */
	public static final int COL_TYPE = 2;

	private JFrame frame = null;

	private JTree tree = null;
	private JTable jt = null;
	private JPopupMenu jmTable = null;
	private JPopupMenu jmTree = null;

	private boolean readOnly = false;
	private boolean modified = false;

	private Hashtable<JavancoXMLElement,PropertiesTableModel> tableModels = new Hashtable<JavancoXMLElement,PropertiesTableModel>();

	private int rowRightClicked = -1;
	private PropertiesTableModel modelRightClicked = null;

	/**
	 * Creates a new <code>XMLDefinitionEditor</code> as a modal
	 * or non-modal <code>JDialog</code> associated to the given <code>JFrame</code>.
	 * <br>#author lchatela
	 * @param f the <code>JFrame</code> from which the dialog is displayed
	 * @param modal <code>true for a modal dialog, <code>false for one that allows other
	 * 		windows to be active at the same time
	 * @param editable <code>true</code> if the properties are editable,
	 * 		<code>false</code> if they are in read-only mode.
	 */
	public XMLDefinitionEditor(JFrame f, boolean modal, boolean editable) {
		super(f, "Properties", true);
		readOnly = !editable;
		if (readOnly) {
			this.setTitle("Properties (read-only)");
		}
		frame = f;

		InternalUI internalUI = new InternalUI(this);

		/* contSplitPane + its content */
		tree = new JTree();
		tree.setEditable(true);
		tree.setRootVisible(false);
		tree.addTreeSelectionListener(internalUI);
		tree.addMouseListener(internalUI);
		ImageIcon leafIcon = IconLoader.createImageIcon("simple_node.png");
		ImageIcon closedIcon = IconLoader.createImageIcon("folder_close.png");
		ImageIcon openIcon = IconLoader.createImageIcon("folder_open.png");

		if (leafIcon != null) {
			DefaultTreeCellRenderer renderer = new DefaultTreeCellRenderer();
			//renderer.setLeafIcon(leafIcon);
			renderer.setClosedIcon(closedIcon);
			renderer.setOpenIcon(openIcon);
			tree.setCellRenderer(renderer);
		} else {
			System.err.println("Leaf icon missing; using default.");
		}

		jt = new JTable();
		jt.addMouseListener(internalUI);

		JScrollPane treeView = new JScrollPane(tree);
		JScrollPane tableView = new JScrollPane(jt);

		JSplitPane splitPane = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT);

		splitPane.setLeftComponent(treeView);
		splitPane.setRightComponent(tableView);
		splitPane.setDividerLocation(200);
		splitPane.setPreferredSize(new Dimension(700,300));

		JPanel contSplitPane = new JPanel();
		contSplitPane.setLayout(new BoxLayout(contSplitPane, BoxLayout.X_AXIS));
		contSplitPane.add(splitPane);

		JPanel buttonPane = new JPanel();
		JButton cancelButton;
		if (readOnly) {
			cancelButton = new JButton("OK");
			cancelButton.setActionCommand("ok");
			cancelButton.setToolTipText("Close this window");
			cancelButton.addActionListener(internalUI);
		} else {
			/* buttonPane + its content */
			JButton okButton = new JButton("OK");
			cancelButton = new JButton("Cancel");

			okButton.setActionCommand("ok");
			okButton.addActionListener(internalUI);
			okButton.setToolTipText("Keep the changes");
			cancelButton.setActionCommand("cancel");
			cancelButton.addActionListener(internalUI);
			cancelButton.setToolTipText("Discard the changes");

			buttonPane.add(okButton);
		}

		buttonPane.add(cancelButton);

		buttonPane.setLayout(new BoxLayout(buttonPane, BoxLayout.X_AXIS));
		buttonPane.setBorder(BorderFactory.createEmptyBorder(5, 5, 5, 5));
		buttonPane.add(Box.createHorizontalGlue());
		buttonPane.add(Box.createRigidArea(new Dimension(10, 0)));

		JPanel mainPane = new JPanel();
		mainPane.setLayout(new BoxLayout(mainPane, BoxLayout.Y_AXIS));

		mainPane.add(contSplitPane);
		mainPane.add(buttonPane);

		this.setContentPane(mainPane);
		this.pack();
		this.addWindowListener(internalUI);
	}

	/**
	 * Returns the table model corresponding to the given element, i.e. the content to display
	 * in the <code>JTable</code>.<br/>
	 * If no table model exists for this element, creates the corresponding table model and
	 * inserts it in <code>tableModels</code>.
	 * <br>#author lchatela
	 * @param elem the <code>JavancoXMLElement</code> to represent in the model
	 * @return the table model corresponding to the given element.
	 */
	private PropertiesTableModel getModel(JavancoXMLElement elem) {
		PropertiesTableModel model = tableModels.get(elem);
		if (model == null){
			model = new PropertiesTableModel(elem);
			model.addTableModelListener(new PropertiesTableModelListener());
			tableModels.put(elem,model);
		}
		return model;
	}

	/**
	 * Returns the attribute in the list corresponding to the given name, <code>null</code>
	 * if none.
	 * <br>#author lchatela
	 * @param attributes The list of attributes in which to fetch
	 * @param name The name of the attribute to return
	 * @return The attribute in the list corresponding to the given name, or <code>null</code> if none.
	 */
	@SuppressWarnings("unchecked")
	private NetworkAttribute get(List attributes, String name) {
		for (NetworkAttribute att : (List<NetworkAttribute>) attributes) {
			if (att.getName().equals(name)) {
				return att;
			}
		}
		return null;
	}

	/**
	 * Displays the properties window.
	 * @param elC the <code>AbstractElementContainer</code> corresponding to the
	 * 		element whose properties the user wants to see.
	 * @return <code>true</code> if some of the properties have been modified.
	 */
	public boolean editElement(AbstractElementContainer elC) {
		//Vector<Element> list = elC.getElementAccordingPriority();
		Map<String,JavancoXMLElement> map = elC.getElementMap();
		if (map != null) {
			XMLElementTree xmlTree = new XMLElementTree(map, elC.getContainedElementKeyword().toString());
			tree.setModel(xmlTree.getTreeModel());
			tree.setSelectionInterval(0, 0);
		}
		setLocation(100,150);
		setVisible(true);
		repaint();
		return modified;
	}

/*	private void toTree(JavancoXMLElement element, DefaultMutableTreeNode rootNode) {
		if (element != null) {
			rootNode.setUserObject(element.getName());
			DefaultMutableTreeNode subTree = null;
			for (Object child : element.elements()) {
				JavancoXMLElement sub = (JavancoXMLElement)child;
				subTree = new DefaultMutableTreeNode();
				toTree(sub, subTree);
				rootNode.add(subTree);
			}
		}
	}*/

	/**
	 * Method called when the user chooses to delete an attribute in the
	 * contextual menu.
	 * <br>#author lchatela
	 */
	private void deleteAttribute() {
		modelRightClicked.removeRow(rowRightClicked);
		modified = true;
	}

	/**
	 * Method called when the user chooses to add an attribute in the
	 * contextual menu.
	 * <br>#author lchatela
	 */
	private void addAttribute() {
		String name = javax.swing.JOptionPane.showInputDialog(
				new Frame(),
				"Enter the name of the attribute",
		"");
		//If a string was returned.
		if ((name != null) && (name.length() > 0)) {
			String value = javax.swing.JOptionPane.showInputDialog(
					new Frame(),
					"Enter the value of the attribute \""+name+"\"",
			"");
			if (value != null) {
				modelRightClicked.addRow(name, value);
				modified = true;
			}
		}
	}

	private class InternalUI implements MouseListener, TreeSelectionListener, ActionListener, WindowListener {

		private JDialog outerClass = null;

		private InternalUI(JDialog diag) {
			outerClass = diag;
		}

		/* Implementation of TreeSelectionListener */
		/**
		 * Method called when the user clicks on another element in the <code>JTree</code>.<br/>
		 * Displays the corresponding <code>PropertiesTableModel</code>.
		 */
		public void valueChanged(TreeSelectionEvent e) {
			if (tree.getSelectionPath() == null) {
				return;
			}
			XMLElementNodeTree selectedNode = (XMLElementNodeTree)tree.getSelectionPath().getLastPathComponent();
			JavancoXMLElement el = (JavancoXMLElement)selectedNode.getUserObject();
			// checks wether the corresponding table model already exists, and if not creates it
			jt.setModel(getModel(el));
		}


		/* Implementation of ActionListener */
		/**
		 * Method called when the user clicks on the "OK" or "cancel" button.<br>
		 * If the user clicked on the "OK" button, executes all the stored
		 * <code>PropertiesTableModelEvents</code>.
		 * <br>#author lchatela
		 */
		public void actionPerformed(ActionEvent e) {
			if ("ok".equals(e.getActionCommand())) {
				for (PropertiesTableModel tableModel : tableModels.values()) {
					for (TableModelListener listener : tableModel.getTableModelListeners()) {
						if (listener instanceof PropertiesTableModelListener) {
							((PropertiesTableModelListener)listener).executeEvents();
						}
					}
				}
			}
			// in both cases (ok or cancel)
			outerClass.dispose();
		}

		/* Implementation of MouseListener */
		/**
		 * Method called when the user clicks in the <code>JDialog</code>.<br>
		 * If the user right-clicked in the <code>JTree</code> (elements) or the
		 * <code>JTable</code> (attributes), displays the corresponding contextual
		 * menu.
		 * @param e the <code>MouseEvent</code> generated by the user's click
		 * <br>#author lchatela
		 */
		public void mouseClicked(MouseEvent e) {
			if (readOnly) {
				return;
			}
			if (e.getButton() == MouseEvent.BUTTON3) {

				/* if the user right-clicked on an element */
				if (e.getSource() instanceof JTree) {
					JTree treeSource = (JTree) e.getSource();
					rowRightClicked = treeSource.getRowForLocation(e.getX(), e.getY());
					treeSource.setSelectionRow(rowRightClicked);
					if (treeSource.getSelectionPath() == null) {
						return;
					}
					XMLElementNodeTree selectedNode = (XMLElementNodeTree)treeSource.getSelectionPath().getLastPathComponent();
					JavancoXMLElement el = (JavancoXMLElement)selectedNode.getUserObject();

					if (!el.isModifiable()) {
						return;
					}
					modelRightClicked = getModel(el);

					jmTree = new JPopupMenu();
					JMenuItem add = new JMenuItem("Add attribute");
					add.addActionListener(new ActionListener(){
						public void actionPerformed(ActionEvent e){
							addAttribute();
						}
					});
					jmTree.add(add);
					jmTree.pack();
					jmTree.show(treeSource,e.getX(), e.getY());
				}

				/* if the user right-clicked on an attribute */
				if (e.getSource() instanceof JTable) {
					JTable tableSource = (JTable) e.getSource();
					Point p = e.getPoint();
					rowRightClicked = tableSource.rowAtPoint(p);
					tableSource.changeSelection(rowRightClicked, 0, false, false);
					modelRightClicked = (PropertiesTableModel)tableSource.getModel();
					// Checks whether the attribute can be deleted or not.
					// The attribute cannot be deleted if it is Main, Core or locked
					String nameAttRightClicked = (String)modelRightClicked.getValueAt(rowRightClicked, COL_NAME);
					if (XMLTagKeywords.parse(nameAttRightClicked).isCore() || XMLTagKeywords.parse(nameAttRightClicked).isMain()) {
						return;
					}
					List<NetworkAttribute> attList = modelRightClicked.getAttributeList();
					NetworkAttribute attRightClicked = get(attList, nameAttRightClicked);
					if (attRightClicked != null && !attRightClicked.isDeletable()) {
						return;
					}

					jmTable = new JPopupMenu();
					JMenuItem del = new JMenuItem("Delete");
					del.addActionListener(new ActionListener(){
						public void actionPerformed(ActionEvent e){
							deleteAttribute();
						}
					});
					JMenuItem add = new JMenuItem("Add attribute");
					add.addActionListener(new ActionListener(){
						public void actionPerformed(ActionEvent e){
							addAttribute();
						}
					});
					jmTable.add(add);
					jmTable.add(del);
					jmTable.pack();
					jmTable.show(tableSource,e.getX(), e.getY());
				}

				repaint();
			}
		}

		/**
		 * Method mousePressed
		 * @param parm1
		 *
		 */
		public void mousePressed(MouseEvent parm1) {
			repaint();
		}

		/**
		 * Method mouseReleased
		 * @param parm1
		 *
		 */
		public void mouseReleased(MouseEvent parm1) {

		}

		/**
		 * Method mouseEntered
		 * @param parm1
		 *
		 */
		public void mouseEntered(MouseEvent parm1) {
			repaint();
		}

		/**
		 * Method mouseExited
		 * @param parm1
		 *
		 */
		public void mouseExited(MouseEvent parm1) {
			repaint();
		}

		/* Implementation of WindowListener */
		/**
		 * Method windowOpened
		 * @param parm1
		 *
		 */
		public void windowOpened(WindowEvent parm1) {
		}

		/**
		 * Method windowClosing
		 * @param parm1
		 *
		 */
		public void windowClosing(WindowEvent parm1) {
			synchronized(this) {
				notifyAll();
			}
		}

		/**
		 * Method windowClosed
		 * @param parm1
		 *
		 */
		public void windowClosed(WindowEvent parm1) {

		}

		/**
		 * Method windowIconified
		 * @param parm1
		 *
		 */
		public void windowIconified(WindowEvent parm1) {
		}

		/**
		 * Method windowDeiconified
		 * @param parm1
		 *
		 */
		public void windowDeiconified(WindowEvent parm1) {
		}

		/**
		 * Method windowActivated
		 * @param parm1
		 *
		 */
		public void windowActivated(WindowEvent parm1) {

		}

		/**
		 * Method windowDeactivated
		 * @param parm1
		 *
		 */
		public void windowDeactivated(WindowEvent parm1) {
		}
	}
}
